CCS PCH C Compiler, Version 4.114, 93460303               31-Aug-18 14:32

               Filename: C:\Users\PC\Desktop\trivium_2_picc\PIC 32byte input\main.lst

               ROM used: 2994 bytes (9%)
                         Largest free fragment is 29774
               RAM used: 154 (8%) at main() level
                         236 (12%) worst case
               Stack:    7 locations

*
0000:  GOTO   09CE
.................... // The header file for the microcontroller. Change this if your microcontroller is different 
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
0004:  MOVFF  D9,DF
0008:  MOVFF  D8,DE
....................    sc2=s2; 
000C:  MOVFF  DB,E1
0010:  MOVFF  DA,E0
....................    if(sc2<sc1 && sc1 <sc2 +n) 
0014:  MOVF   xE1,W
0016:  SUBWF  xDF,W
0018:  BNC   008A
001A:  BNZ   0022
001C:  MOVF   xDE,W
001E:  SUBWF  xE0,W
0020:  BC    008A
0022:  MOVF   xDC,W
0024:  ADDWF  xE0,W
0026:  MOVWF  01
0028:  MOVF   xDD,W
002A:  ADDWFC xE1,W
002C:  MOVWF  03
002E:  MOVF   xDF,W
0030:  SUBWF  03,W
0032:  BNC   008A
0034:  BNZ   003C
0036:  MOVF   01,W
0038:  SUBWF  xDE,W
003A:  BC    008A
....................       for(sc1+=n,sc2+=n;0<n;--n) 
003C:  MOVF   xDC,W
003E:  ADDWF  xDE,F
0040:  MOVF   xDD,W
0042:  ADDWFC xDF,F
0044:  MOVF   xDC,W
0046:  ADDWF  xE0,F
0048:  MOVF   xDD,W
004A:  ADDWFC xE1,F
004C:  MOVF   xDD,F
004E:  BNZ   0056
0050:  MOVF   xDC,W
0052:  SUBLW  00
0054:  BC    0088
....................          *--sc1=*--sc2; 
0056:  MOVF   xDE,W
0058:  BTFSC  FD8.2
005A:  DECF   xDF,F
005C:  DECF   xDE,F
005E:  MOVF   xE0,W
0060:  BTFSC  FD8.2
0062:  DECF   xE1,F
0064:  DECF   xE0,F
0066:  MOVFF  E0,FE9
006A:  MOVFF  E1,FEA
006E:  MOVFF  FEF,E4
0072:  MOVFF  DF,FEA
0076:  MOVFF  DE,FE9
007A:  MOVFF  E4,FEF
007E:  MOVF   xDC,W
0080:  BTFSC  FD8.2
0082:  DECF   xDD,F
0084:  DECF   xDC,F
0086:  BRA    004C
....................    else 
0088:  BRA    00D2
....................       for(;0<n;--n) 
008A:  MOVF   xDD,F
008C:  BNZ   0094
008E:  MOVF   xDC,W
0090:  SUBLW  00
0092:  BC    00D2
....................          *sc1++=*sc2++; 
0094:  MOVFF  DF,03
0098:  MOVF   xDE,W
009A:  INCF   xDE,F
009C:  BTFSC  FD8.2
009E:  INCF   xDF,F
00A0:  MOVWF  xE2
00A2:  MOVFF  03,E3
00A6:  MOVFF  E1,03
00AA:  MOVF   xE0,W
00AC:  INCF   xE0,F
00AE:  BTFSC  FD8.2
00B0:  INCF   xE1,F
00B2:  MOVWF  FE9
00B4:  MOVFF  03,FEA
00B8:  MOVFF  FEF,E4
00BC:  MOVFF  E3,FEA
00C0:  MOVFF  E2,FE9
00C4:  MOVFF  E4,FEF
00C8:  MOVF   xDC,W
00CA:  BTFSC  FD8.2
00CC:  DECF   xDD,F
00CE:  DECF   xDC,F
00D0:  BRA    008A
....................   return s1; 
00D2:  MOVFF  D8,01
00D6:  MOVFF  D9,02
....................   } 
00DA:  RETLW  00
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define STATELENGTH 36 
.................... #define KEYLENGTH   10 
.................... #define IVLENGTH    10 
....................  
.................... typedef uint8_t u8; 
.................... typedef long u64; 
....................  
.................... void ip_encrypt(u8* key, u8* iv, u8* input, u64 length); 
.................... void ip_decrypt(u8* key, u8* iv, u8* input, u64 length); 
....................  
.................... u8* encrypt(u8* key, u8* iv, u8* input, u64 length); 
.................... u8* decrypt(u8* key, u8* iv, u8* input, u64 length); 
....................  
.................... /************************************************ DEVICE DEPENDENT CONFIGURATION *******************************************************/ 
....................  
....................  
.................... //configurations bits. Note that these changes depending on the microcontroller 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,PLL2,CPUDIV1,NOVREGEN,NOBROWNOUT,NOMCLR   
.................... /* 
.................... HSPLL - High Speed Crystal/Resonator with PLL enabled. HSPLL requires the crystal to be >=4MHz 
.................... NOWDT - disable watch dog timer       
.................... NOPROTECT - Code not protected from reading 
.................... NOLVP - No low voltage programming, BB5 used for I/O 
.................... NODEBUG - No Debug mode for ICD 
.................... PLL2 - Divide By 2(8MHz oscillator input). The input crystal frequency must be divided and brought to 4MHz to be fed to the PLL. PLL converts the 4MHz signal to 96MHz. Since our crustal is 8MHz we divide by 2 to bring it to 4MHz by specifying PLL2 
.................... CPUDIV1 - No System Clock Postscaler. 
.................... NOVREGEN - Internal voltage regulator disabled 
.................... NOBROWNOUT - No brownout reset 
.................... NOMCLR - No master clear reset 
.................... */ 
.................... //configuration is such that a 8MHz crystal input is converted to operate at 48MHz 
....................  
.................... //the effective clock frequency (48MHz) to be used for things like serial port communication, sleep etc 
.................... #use delay(clock=48000000) 
*
09A4:  CLRF   FEA
09A6:  MOVLW  97
09A8:  MOVWF  FE9
09AA:  MOVF   FEF,W
09AC:  BZ    09CA
09AE:  MOVLW  0F
09B0:  MOVWF  01
09B2:  CLRF   00
09B4:  DECFSZ 00,F
09B6:  BRA    09B4
09B8:  DECFSZ 01,F
09BA:  BRA    09B2
09BC:  MOVLW  8F
09BE:  MOVWF  00
09C0:  DECFSZ 00,F
09C2:  BRA    09C0
09C4:  NOP   
09C6:  DECFSZ FEF,F
09C8:  BRA    09AE
09CA:  GOTO   0BAE (RETURN)
.................... //settings for the UART 
.................... #use rs232(UART1,baud=9600,parity=N,bits=8) 
....................  
....................  
.................... /************* 
....................  * Utilities * 
....................  *************/ 
....................  
....................  
....................  
.................... /*** 
....................  * scw (subsequent crosswrite) 
....................  * 
....................  * write the last n bits of a byte into the first n bits of the next 
....................  * 
....................  */ 
.................... void scw(u8* split, u64 offset) { 
*
0572:  MOVFF  D8,DC
0576:  MOVFF  D7,DB
057A:  MOVLW  01
057C:  SUBWF  xD7,W
057E:  MOVWF  xDD
0580:  MOVLW  00
0582:  SUBWFB xD8,W
0584:  MOVWF  xDE
0586:  MOVLW  08
0588:  BSF    FD8.0
058A:  SUBFWB xD9,W
058C:  MOVWF  00
058E:  MOVLW  00
0590:  SUBFWB xDA,W
0592:  MOVWF  03
0594:  MOVF   00,W
0596:  CLRF   03
0598:  MOVLW  FF
059A:  MOVWF  02
059C:  MOVF   00,F
059E:  BZ    05AA
05A0:  BCF    FD8.0
05A2:  RLCF   02,F
05A4:  RLCF   03,F
05A6:  DECFSZ 00,F
05A8:  BRA    05A0
05AA:  MOVFF  02,DF
05AE:  MOVFF  DD,FE9
05B2:  MOVFF  DE,FEA
05B6:  MOVFF  FEF,E1
05BA:  MOVLW  08
05BC:  BSF    FD8.0
05BE:  SUBFWB xD9,W
05C0:  MOVWF  00
05C2:  MOVLW  00
05C4:  SUBFWB xDA,W
05C6:  MOVWF  03
05C8:  MOVFF  00,01
05CC:  MOVFF  E1,E0
05D0:  MOVF   01,F
05D2:  BZ    05DC
05D4:  BCF    FD8.0
05D6:  RLCF   xE0,F
05D8:  DECFSZ 01,F
05DA:  BRA    05D4
....................  
....................   u8* post = split; 
....................   u8* pre  = split - 1; 
....................  
....................   // e.g., for 3 -> 11111111 shifted to 11100000 
....................   u8 mask = 0xFF << (8 - offset); 
....................  
....................   // e.g., for 3 -> 00000101 shifted to 10100000 
....................   u8 shifted = (*pre) << (8 - offset); 
....................  
....................   (*post) = (*post & ~mask) | (shifted & mask); 
05DC:  MOVFF  DC,03
05E0:  MOVF   xDB,W
05E2:  MOVWF  xE1
05E4:  MOVFF  03,E2
05E8:  MOVFF  DB,FE9
05EC:  MOVFF  DC,FEA
05F0:  MOVFF  FEF,E3
05F4:  MOVF   xDF,W
05F6:  XORLW  FF
05F8:  ANDWF  xE3,F
05FA:  MOVF   xE0,W
05FC:  ANDWF  xDF,W
05FE:  IORWF  xE3,W
0600:  MOVFF  E2,FEA
0604:  MOVFF  E1,FE9
0608:  MOVWF  FEF
....................   (*pre) >>= offset; 
060A:  MOVFF  DE,03
060E:  MOVFF  DD,FE9
0612:  MOVFF  DE,FEA
0616:  MOVF   FEF,W
0618:  CLRF   03
061A:  MOVWF  02
061C:  MOVF   xD9,W
061E:  MOVWF  00
0620:  BZ    062C
0622:  BCF    FD8.0
0624:  RRCF   03,F
0626:  RRCF   02,F
0628:  DECFSZ 00,F
062A:  BRA    0622
062C:  MOVF   02,W
062E:  MOVWF  FEF
....................  
....................   return; 
.................... } 
0630:  GOTO   07CA (RETURN)
....................  
....................  
.................... /*** 
....................  * acw (antecedent crosswrite) 
....................  * 
....................  * write the first n bits of a byte into the last n bits of the previous 
....................  * 
....................  */ 
.................... void acw(u8* split, u64 offset) { 
*
0194:  MOVFF  D7,DB
0198:  MOVFF  D6,DA
019C:  MOVLW  01
019E:  SUBWF  xD6,W
01A0:  MOVWF  xDC
01A2:  MOVLW  00
01A4:  SUBWFB xD7,W
01A6:  MOVWF  xDD
01A8:  CLRF   xE1
01AA:  MOVLW  01
01AC:  MOVWF  xE0
01AE:  MOVF   xD8,W
01B0:  MOVWF  00
01B2:  BZ    01BE
01B4:  BCF    FD8.0
01B6:  RLCF   xE0,F
01B8:  RLCF   xE1,F
01BA:  DECFSZ 00,F
01BC:  BRA    01B4
01BE:  MOVLW  01
01C0:  SUBWF  xE0,W
01C2:  MOVWF  xDE
01C4:  MOVF   xDA,W
01C6:  MOVWF  FE9
01C8:  MOVFF  DB,FEA
01CC:  MOVFF  FEF,E0
01D0:  MOVLW  08
01D2:  BSF    FD8.0
01D4:  SUBFWB xD8,W
01D6:  MOVWF  00
01D8:  MOVLW  00
01DA:  SUBFWB xD9,W
01DC:  MOVWF  03
01DE:  MOVF   00,W
01E0:  MOVWF  01
01E2:  MOVFF  E0,DF
01E6:  MOVF   01,F
01E8:  BZ    01F2
01EA:  BCF    FD8.0
01EC:  RRCF   xDF,F
01EE:  DECFSZ 01,F
01F0:  BRA    01EA
....................  
....................   u8* post = split; 
....................   u8* pre  = split - 1; 
....................  
....................   // e.g., for 3 -> 00000001 shifted to 00001000 becomes 00000111 
....................   u8 mask = (0x01 << offset) - 1; 
....................  
....................   // e.g., for 3 -> 10100000 shifted to 00000101 
....................   u8 shifted = (*post) >> (8 - offset); 
....................  
....................   (*pre) = (*pre & ~mask) | (shifted & mask); 
01F2:  MOVFF  DD,03
01F6:  MOVFF  03,E1
01FA:  MOVFF  DC,FE9
01FE:  MOVFF  DD,FEA
0202:  MOVFF  FEF,E2
0206:  MOVF   xDE,W
0208:  XORLW  FF
020A:  ANDWF  xE2,F
020C:  MOVF   xDF,W
020E:  ANDWF  xDE,W
0210:  IORWF  xE2,W
0212:  MOVFF  E1,FEA
0216:  MOVFF  DC,FE9
021A:  MOVWF  FEF
....................   (*post) <<= offset; 
021C:  MOVFF  DB,03
0220:  MOVFF  DA,FE9
0224:  MOVFF  DB,FEA
0228:  MOVF   FEF,W
022A:  CLRF   03
022C:  MOVWF  02
022E:  MOVF   xD8,W
0230:  MOVWF  00
0232:  BZ    023E
0234:  BCF    FD8.0
0236:  RLCF   02,F
0238:  RLCF   03,F
023A:  DECFSZ 00,F
023C:  BRA    0234
023E:  MOVF   02,W
0240:  MOVWF  FEF
....................  
....................   return; 
.................... } 
0242:  GOTO   02AE (RETURN)
....................  
....................  
....................  
.................... /***************** 
....................  * Initialization * 
....................  *****************/ 
....................  
....................  
....................  
.................... /*** 
....................  * insert_byte 
....................  * 
....................  * insert a byte a repeat number of times 
....................  * 
....................  */ 
.................... void insert_byte(u8** p_mark, u8* b8, u64 repeat) { 
*
0128:  MOVFF  CE,FE9
012C:  MOVFF  CF,FEA
0130:  MOVFF  FEC,03
0134:  MOVF   FED,F
0136:  MOVFF  FEF,D4
013A:  MOVFF  03,D5
....................  
....................   u8* mark = (*p_mark); 
....................   u64 iter; 
....................  
....................   for (iter = 0; iter < repeat; iter++) { 
013E:  CLRF   xD7
0140:  CLRF   xD6
0142:  MOVF   xD7,W
0144:  SUBWF  xD3,W
0146:  BNC   0180
0148:  BNZ   0150
014A:  MOVF   xD2,W
014C:  SUBWF  xD6,W
014E:  BC    0180
....................     mark = memmove(mark, b8, 1); 
0150:  MOVFF  D5,D9
0154:  MOVFF  D4,D8
0158:  MOVFF  D1,DB
015C:  MOVFF  D0,DA
0160:  CLRF   xDD
0162:  MOVLW  01
0164:  MOVWF  xDC
0166:  RCALL  0004
0168:  MOVFF  02,D5
016C:  MOVFF  01,D4
....................     mark += 1; 
0170:  MOVLW  01
0172:  ADDWF  xD4,F
0174:  MOVLW  00
0176:  ADDWFC xD5,F
....................   } 
0178:  INCF   xD6,F
017A:  BTFSC  FD8.2
017C:  INCF   xD7,F
017E:  BRA    0142
....................  
....................   (*p_mark) = mark; 
0180:  MOVFF  CE,FE9
0184:  MOVFF  CF,FEA
0188:  MOVFF  D5,FEC
018C:  MOVF   FED,F
018E:  MOVFF  D4,FEF
....................  
....................   return; 
.................... } 
0192:  RETLW  00
....................  
....................  
.................... /*** 
....................  * insert_key 
....................  * 
....................  * insert the key into the state 
....................  * 
....................  */ 
.................... void insert_key(u8** p_mark, u8* key) { 
*
00DC:  MOVFF  CE,FE9
00E0:  MOVFF  CF,FEA
00E4:  MOVFF  FEC,03
00E8:  MOVF   FED,F
00EA:  MOVFF  FEF,D2
00EE:  MOVFF  03,D3
....................  
....................   u8* mark = (*p_mark); 
....................  
....................   memmove(mark, key, KEYLENGTH); 
00F2:  MOVFF  D3,D9
00F6:  MOVFF  D2,D8
00FA:  MOVFF  D1,DB
00FE:  MOVFF  D0,DA
0102:  CLRF   xDD
0104:  MOVLW  0A
0106:  MOVWF  xDC
0108:  RCALL  0004
....................   mark += KEYLENGTH; 
010A:  MOVLW  0A
010C:  ADDWF  xD2,F
010E:  MOVLW  00
0110:  ADDWFC xD3,F
....................  
....................   (*p_mark) = mark; 
0112:  MOVFF  CE,FE9
0116:  MOVFF  CF,FEA
011A:  MOVFF  D3,FEC
011E:  MOVF   FED,F
0120:  MOVFF  D2,FEF
....................  
....................   return; 
.................... } 
0124:  GOTO   02F0 (RETURN)
....................  
....................  
.................... /*** 
....................  * insert_iv 
....................  * 
....................  * insert the iv - this requires cross writing 
....................  * across bytes, since the iv is not positioned 
....................  * on a clean byte boundary in the state 
....................  * 
....................  */ 
.................... void insert_iv(u8** p_mark, u8* iv) { 
*
0246:  MOVFF  CE,FE9
024A:  MOVFF  CF,FEA
024E:  MOVFF  FEC,03
0252:  MOVF   FED,F
0254:  MOVFF  FEF,D4
0258:  MOVFF  03,D5
....................  
....................  // u8* temp; 
....................   u64 iter; 
....................   u8* mark = (*p_mark); 
....................  
....................   // zero out the current byte - we'll acw 
....................   // the first three bits of the iv into it. 
....................   (*mark) = 0x00; 
025C:  MOVFF  D4,FE9
0260:  MOVFF  D5,FEA
0264:  CLRF   FEF
....................   mark += 1; 
0266:  MOVLW  01
0268:  ADDWF  xD4,F
026A:  MOVLW  00
026C:  ADDWFC xD5,F
....................  
....................   for (iter = 0; iter < IVLENGTH; iter++) { 
026E:  CLRF   xD3
0270:  CLRF   xD2
0272:  MOVF   xD3,F
0274:  BNZ   02BE
0276:  MOVF   xD2,W
0278:  SUBLW  09
027A:  BNC   02BE
....................     memmove(mark, iv + iter, 1); 
027C:  MOVF   xD2,W
027E:  ADDWF  xD0,W
0280:  MOVWF  xD6
0282:  MOVF   xD3,W
0284:  ADDWFC xD1,W
0286:  MOVWF  xD7
0288:  MOVFF  D5,D9
028C:  MOVFF  D4,D8
0290:  MOVWF  xDB
0292:  MOVFF  D6,DA
0296:  CLRF   xDD
0298:  MOVLW  01
029A:  MOVWF  xDC
029C:  RCALL  0004
....................     acw(mark, 3); 
029E:  MOVFF  D5,D7
02A2:  MOVFF  D4,D6
02A6:  CLRF   xD9
02A8:  MOVLW  03
02AA:  MOVWF  xD8
02AC:  BRA    0194
....................  
....................     mark += 1; 
02AE:  MOVLW  01
02B0:  ADDWF  xD4,F
02B2:  MOVLW  00
02B4:  ADDWFC xD5,F
....................   } 
02B6:  INCF   xD2,F
02B8:  BTFSC  FD8.2
02BA:  INCF   xD3,F
02BC:  BRA    0272
....................  
....................   (*p_mark) = mark; 
02BE:  MOVFF  CE,FE9
02C2:  MOVFF  CF,FEA
02C6:  MOVFF  D5,FEC
02CA:  MOVF   FED,F
02CC:  MOVFF  D4,FEF
....................  
....................   return; 
.................... } 
02D0:  GOTO   0314 (RETURN)
....................  
.................... u8 stateee[STATELENGTH]; 
....................  
.................... /*** 
....................  * setup 
....................  * 
....................  * setup the state per the key and iv 
....................  * 
....................  */ 
.................... u8* setup(u8* key, u8* iv) { 
02D4:  CLRF   xCB
02D6:  MOVLW  0A
02D8:  MOVWF  xCA
02DA:  CLRF   xCC
02DC:  MOVLW  07
02DE:  MOVWF  xCD
....................   //u8* stateee; 
....................  
....................   u8* mark = stateee; 
....................  
....................   u8 zero = 0x00; // 00000000 
....................   u8 end  = 0x07; // 00000111 
....................  
....................   // the insert_* functions increment mark accordingly 
....................  
....................   insert_key(&mark, key); 
02E0:  CLRF   xCF
02E2:  MOVLW  CA
02E4:  MOVWF  xCE
02E6:  MOVFF  C7,D1
02EA:  MOVFF  C6,D0
02EE:  BRA    00DC
....................  
....................   insert_byte(&mark, &zero, 1); 
02F0:  CLRF   xCF
02F2:  MOVLW  CA
02F4:  MOVWF  xCE
02F6:  CLRF   xD1
02F8:  MOVLW  CC
02FA:  MOVWF  xD0
02FC:  CLRF   xD3
02FE:  MOVLW  01
0300:  MOVWF  xD2
0302:  RCALL  0128
....................  
....................   insert_iv(&mark, iv); 
0304:  CLRF   xCF
0306:  MOVLW  CA
0308:  MOVWF  xCE
030A:  MOVFF  C9,D1
030E:  MOVFF  C8,D0
0312:  BRA    0246
....................  
....................   insert_byte(&mark, &zero, 13); 
0314:  CLRF   xCF
0316:  MOVLW  CA
0318:  MOVWF  xCE
031A:  CLRF   xD1
031C:  MOVLW  CC
031E:  MOVWF  xD0
0320:  CLRF   xD3
0322:  MOVLW  0D
0324:  MOVWF  xD2
0326:  RCALL  0128
....................   insert_byte(&mark, &end, 1); 
0328:  CLRF   xCF
032A:  MOVLW  CA
032C:  MOVWF  xCE
032E:  CLRF   xD1
0330:  MOVLW  CD
0332:  MOVWF  xD0
0334:  CLRF   xD3
0336:  MOVLW  01
0338:  MOVWF  xD2
033A:  RCALL  0128
....................  
....................   return stateee; 
033C:  MOVLW  0A
033E:  MOVWF  01
0340:  MOVLW  00
0342:  MOVWF  02
.................... } 
0344:  RETLW  00
....................  
....................  
....................  
.................... /************************ 
....................  * Keystream Generation * 
....................  ************************/ 
....................  
....................  
....................  
.................... /*** 
....................  * gb 
....................  * 
....................  * get the bit at a given index in a byte 
....................  * 
....................  */ 
.................... u8 gb(u8* from, u64 index) { 
*
0446:  MOVFF  E0,FE9
044A:  MOVFF  E1,FEA
044E:  MOVFF  FEF,E6
0452:  MOVLW  07
0454:  BSF    FD8.0
0456:  SUBFWB xE2,W
0458:  MOVWF  00
045A:  MOVLW  00
045C:  SUBFWB xE3,W
045E:  MOVWF  03
0460:  MOVFF  00,01
0464:  MOVFF  E6,E5
0468:  MOVF   01,F
046A:  BZ    0474
046C:  BCF    FD8.0
046E:  RRCF   xE5,F
0470:  DECFSZ 01,F
0472:  BRA    046C
....................  
....................   u8 b8 = (*from); 
....................  
....................   u8 shifted = b8 >> (7 - index); 
....................  
....................   return shifted & 0x01; 
0474:  MOVF   xE5,W
0476:  ANDLW  01
0478:  MOVWF  01
.................... } 
047A:  GOTO   04B6 (RETURN)
....................  
....................  
.................... /*** 
....................  * pb 
....................  * 
....................  * put the bit at a given index in a byte 
....................  * 
....................  */ 
.................... void pb(u8* to, u8* from, u64 index) { 
*
04BA:  MOVLW  07
04BC:  BSF    FD8.0
04BE:  SUBFWB xE5,W
04C0:  MOVWF  00
04C2:  MOVLW  00
04C4:  SUBFWB xE6,W
04C6:  MOVWF  03
04C8:  MOVF   00,W
04CA:  CLRF   03
04CC:  MOVLW  01
04CE:  MOVWF  02
04D0:  MOVF   00,F
04D2:  BZ    04DE
04D4:  BCF    FD8.0
04D6:  RLCF   02,F
04D8:  RLCF   03,F
04DA:  DECFSZ 00,F
04DC:  BRA    04D4
04DE:  MOVFF  02,E7
04E2:  MOVFF  E3,FE9
04E6:  MOVFF  E4,FEA
04EA:  MOVFF  FEF,E8
....................  
....................   u8 mask = (0x01 << (7 - index)); 
....................  
....................   u8 put = (*from); 
....................   put <<= (7 - index); 
04EE:  MOVLW  07
04F0:  BSF    FD8.0
04F2:  SUBFWB xE5,W
04F4:  MOVWF  00
04F6:  MOVLW  00
04F8:  SUBFWB xE6,W
04FA:  MOVWF  03
04FC:  MOVFF  00,01
0500:  MOVF   01,F
0502:  BZ    050C
0504:  BCF    FD8.0
0506:  RLCF   xE8,F
0508:  DECFSZ 01,F
050A:  BRA    0504
....................  
....................   (*to) = (*to & ~mask) | (put & mask); 
050C:  MOVFF  E1,FE9
0510:  MOVFF  E2,FEA
0514:  MOVFF  FEF,EB
0518:  MOVF   xE7,W
051A:  XORLW  FF
051C:  ANDWF  xEB,F
051E:  MOVF   xE8,W
0520:  ANDWF  xE7,W
0522:  IORWF  xEB,W
0524:  MOVFF  E2,FEA
0528:  MOVFF  E1,FE9
052C:  MOVWF  FEF
....................  
....................   return; 
.................... } 
052E:  RETLW  00
....................  
....................  
.................... /*** 
....................  * gsb 
....................  * 
....................  * get the bit at a given index in the state 
....................  * 
....................  */ 
.................... u8 gsb(u8* state, u64 index) { 
*
047E:  RRCF   xD9,W
0480:  MOVWF  xDB
0482:  RRCF   xD8,W
0484:  MOVWF  xDA
0486:  RRCF   xDB,F
0488:  RRCF   xDA,F
048A:  RRCF   xDB,F
048C:  RRCF   xDA,F
048E:  MOVLW  1F
0490:  ANDWF  xDB,F
0492:  MOVF   xD8,W
0494:  ANDLW  07
0496:  MOVWF  xDC
0498:  CLRF   xDD
....................  
....................   u64 b8 = index / 8; 
....................   u64 bit  = index % 8; 
....................  
....................   return gb(state + b8, bit); 
049A:  MOVF   xDA,W
049C:  ADDWF  xD6,W
049E:  MOVWF  xDE
04A0:  MOVF   xDB,W
04A2:  ADDWFC xD7,W
04A4:  MOVWF  xDF
04A6:  MOVWF  xE1
04A8:  MOVFF  DE,E0
04AC:  MOVFF  DD,E3
04B0:  MOVFF  DC,E2
04B4:  BRA    0446
04B6:  MOVF   01,W
.................... } 
04B8:  RETLW  00
....................  
....................  
.................... /*** 
....................  * psb 
....................  * 
....................  * put the bit at a given index in the state 
....................  * 
....................  */ 
.................... void psb(u8* state, u8* from, u64 index) { 
*
0530:  RRCF   xDA,W
0532:  MOVWF  xDC
0534:  RRCF   xD9,W
0536:  MOVWF  xDB
0538:  RRCF   xDC,F
053A:  RRCF   xDB,F
053C:  RRCF   xDC,F
053E:  RRCF   xDB,F
0540:  MOVLW  1F
0542:  ANDWF  xDC,F
0544:  MOVF   xD9,W
0546:  ANDLW  07
0548:  MOVWF  xDD
054A:  CLRF   xDE
....................  
....................   u64 b8 = index / 8; 
....................   u64 bit  = index % 8; 
....................  
....................   pb(state + b8, from, bit); 
054C:  MOVF   xDB,W
054E:  ADDWF  xD5,W
0550:  MOVWF  xDF
0552:  MOVF   xDC,W
0554:  ADDWFC xD6,W
0556:  MOVWF  xE0
0558:  MOVWF  xE2
055A:  MOVFF  DF,E1
055E:  MOVFF  D8,E4
0562:  MOVFF  D7,E3
0566:  MOVFF  DE,E6
056A:  MOVFF  DD,E5
056E:  RCALL  04BA
....................  
....................   return; 
.................... } 
0570:  RETLW  00
....................  
....................  
.................... /*** 
....................  *  
....................  * 
....................  * generate a keystream bit and update the state accordingly 
....................  * 
....................  */ 
.................... u8 update(u8* state) { 
*
0634:  CLRF   xD2
....................   u8 t1, t2, t3, z; 
....................   u8 _ = 0x00; 
....................   u64 iter; 
....................  
....................   // indexes are from zero 
....................   t1 = gsb(state, 65)  ^ gsb(state, 92); 
0636:  MOVFF  CD,D7
063A:  MOVFF  CC,D6
063E:  CLRF   xD9
0640:  MOVLW  41
0642:  MOVWF  xD8
0644:  RCALL  047E
0646:  MOVFF  01,D5
064A:  MOVFF  CD,D7
064E:  MOVFF  CC,D6
0652:  CLRF   xD9
0654:  MOVLW  5C
0656:  MOVWF  xD8
0658:  RCALL  047E
065A:  MOVF   xD5,W
065C:  XORWF  01,W
065E:  MOVWF  xCE
....................   t2 = gsb(state, 161) ^ gsb(state, 176); 
0660:  MOVFF  CD,D7
0664:  MOVFF  CC,D6
0668:  CLRF   xD9
066A:  MOVLW  A1
066C:  MOVWF  xD8
066E:  RCALL  047E
0670:  MOVFF  01,D5
0674:  MOVFF  CD,D7
0678:  MOVFF  CC,D6
067C:  CLRF   xD9
067E:  MOVLW  B0
0680:  MOVWF  xD8
0682:  RCALL  047E
0684:  MOVF   xD5,W
0686:  XORWF  01,W
0688:  MOVWF  xCF
....................   t3 = gsb(state, 242) ^ gsb(state, 287); 
068A:  MOVFF  CD,D7
068E:  MOVFF  CC,D6
0692:  CLRF   xD9
0694:  MOVLW  F2
0696:  MOVWF  xD8
0698:  RCALL  047E
069A:  MOVFF  01,D5
069E:  MOVFF  CD,D7
06A2:  MOVFF  CC,D6
06A6:  MOVLW  01
06A8:  MOVWF  xD9
06AA:  MOVLW  1F
06AC:  MOVWF  xD8
06AE:  RCALL  047E
06B0:  MOVF   xD5,W
06B2:  XORWF  01,W
06B4:  MOVWF  xD0
....................     
....................    
....................   z = t1 ^ t2 ^ t3; 
06B6:  MOVF   xCE,W
06B8:  XORWF  xCF,W
06BA:  XORWF  xD0,W
06BC:  MOVWF  xD1
....................    
....................   t1 = t1 ^ (gsb(state, 90)  & gsb(state, 91))  ^ gsb(state, 170); 
06BE:  MOVFF  CD,D7
06C2:  MOVFF  CC,D6
06C6:  CLRF   xD9
06C8:  MOVLW  5A
06CA:  MOVWF  xD8
06CC:  RCALL  047E
06CE:  MOVFF  01,D5
06D2:  MOVFF  CD,D7
06D6:  MOVFF  CC,D6
06DA:  CLRF   xD9
06DC:  MOVLW  5B
06DE:  MOVWF  xD8
06E0:  RCALL  047E
06E2:  MOVF   xD5,W
06E4:  ANDWF  01,W
06E6:  XORWF  xCE,W
06E8:  MOVWF  xD5
06EA:  MOVFF  CD,D7
06EE:  MOVFF  CC,D6
06F2:  CLRF   xD9
06F4:  MOVLW  AA
06F6:  MOVWF  xD8
06F8:  RCALL  047E
06FA:  MOVF   xD5,W
06FC:  XORWF  01,W
06FE:  MOVWF  xCE
....................   t2 = t2 ^ (gsb(state, 174) & gsb(state, 175)) ^ gsb(state, 263); 
0700:  MOVFF  CD,D7
0704:  MOVFF  CC,D6
0708:  CLRF   xD9
070A:  MOVLW  AE
070C:  MOVWF  xD8
070E:  RCALL  047E
0710:  MOVFF  01,D5
0714:  MOVFF  CD,D7
0718:  MOVFF  CC,D6
071C:  CLRF   xD9
071E:  MOVLW  AF
0720:  MOVWF  xD8
0722:  RCALL  047E
0724:  MOVF   xD5,W
0726:  ANDWF  01,W
0728:  XORWF  xCF,W
072A:  MOVWF  xD5
072C:  MOVFF  CD,D7
0730:  MOVFF  CC,D6
0734:  MOVLW  01
0736:  MOVWF  xD9
0738:  MOVLW  07
073A:  MOVWF  xD8
073C:  RCALL  047E
073E:  MOVF   xD5,W
0740:  XORWF  01,W
0742:  MOVWF  xCF
....................   t3 = t3 ^ (gsb(state, 285) & gsb(state, 286)) ^ gsb(state, 68); 
0744:  MOVFF  CD,D7
0748:  MOVFF  CC,D6
074C:  MOVLW  01
074E:  MOVWF  xD9
0750:  MOVLW  1D
0752:  MOVWF  xD8
0754:  RCALL  047E
0756:  MOVFF  01,D5
075A:  MOVFF  CD,D7
075E:  MOVFF  CC,D6
0762:  MOVLW  01
0764:  MOVWF  xD9
0766:  MOVLW  1E
0768:  MOVWF  xD8
076A:  RCALL  047E
076C:  MOVF   xD5,W
076E:  ANDWF  01,W
0770:  XORWF  xD0,W
0772:  MOVWF  xD5
0774:  MOVFF  CD,D7
0778:  MOVFF  CC,D6
077C:  CLRF   xD9
077E:  MOVLW  44
0780:  MOVWF  xD8
0782:  RCALL  047E
0784:  MOVF   xD5,W
0786:  XORWF  01,W
0788:  MOVWF  xD0
....................  
....................   // zero out the last bit so that state material is not 
....................   // written into out of bounds memory when we shift up 
....................   psb(state, &_, 287); 
078A:  MOVFF  CD,D6
078E:  MOVFF  CC,D5
0792:  CLRF   xD8
0794:  MOVLW  D2
0796:  MOVWF  xD7
0798:  MOVLW  01
079A:  MOVWF  xDA
079C:  MOVLW  1F
079E:  MOVWF  xD9
07A0:  RCALL  0530
....................  
....................   // rotate 
....................   for (iter = STATELENGTH; iter > 0; iter--) scw(state + iter, 1); 
07A2:  CLRF   xD4
07A4:  MOVLW  24
07A6:  MOVWF  xD3
07A8:  MOVF   xD3,F
07AA:  BNZ   07B0
07AC:  MOVF   xD4,F
07AE:  BZ    07D4
07B0:  MOVF   xD3,W
07B2:  ADDWF  xCC,W
07B4:  MOVWF  xD5
07B6:  MOVF   xD4,W
07B8:  ADDWFC xCD,W
07BA:  MOVWF  xD6
07BC:  MOVWF  xD8
07BE:  MOVFF  D5,D7
07C2:  CLRF   xDA
07C4:  MOVLW  01
07C6:  MOVWF  xD9
07C8:  BRA    0572
07CA:  MOVF   xD3,W
07CC:  BTFSC  FD8.2
07CE:  DECF   xD4,F
07D0:  DECF   xD3,F
07D2:  BRA    07A8
....................  
....................   // update 
....................   psb(state, &t3, 0); 
07D4:  MOVFF  CD,D6
07D8:  MOVFF  CC,D5
07DC:  CLRF   xD8
07DE:  MOVLW  D0
07E0:  MOVWF  xD7
07E2:  CLRF   xDA
07E4:  CLRF   xD9
07E6:  RCALL  0530
....................   psb(state, &t1, 93); 
07E8:  MOVFF  CD,D6
07EC:  MOVFF  CC,D5
07F0:  CLRF   xD8
07F2:  MOVLW  CE
07F4:  MOVWF  xD7
07F6:  CLRF   xDA
07F8:  MOVLW  5D
07FA:  MOVWF  xD9
07FC:  RCALL  0530
....................   psb(state, &t2, 177); 
07FE:  MOVFF  CD,D6
0802:  MOVFF  CC,D5
0806:  CLRF   xD8
0808:  MOVLW  CF
080A:  MOVWF  xD7
080C:  CLRF   xDA
080E:  MOVLW  B1
0810:  MOVWF  xD9
0812:  RCALL  0530
....................  
....................   return z; 
0814:  MOVFF  D1,01
.................... } 
0818:  RETLW  00
....................  
....................  
.................... /*** 
....................  * stream 
....................  * 
....................  * generate a keystream byte 
....................  * 
....................  */ 
.................... u8 stream(u8* state) { 
....................  
....................   u8 keystream, z; 
....................   u64 bit; 
....................  
....................   output_high (PIN_B0); 
081A:  BCF    F93.0
081C:  BSF    F8A.0
....................   for (bit = 8; bit > 0; bit--) { 
081E:  CLRF   xCB
0820:  MOVLW  08
0822:  MOVWF  xCA
0824:  MOVF   xCA,F
0826:  BNZ   082C
0828:  MOVF   xCB,F
082A:  BZ    0866
....................     z = update(state); 
082C:  MOVFF  C7,CD
0830:  MOVFF  C6,CC
0834:  RCALL  0634
0836:  MOVFF  01,C9
....................     pb(&keystream, &z, (bit - 1)); 
083A:  MOVLW  01
083C:  SUBWF  xCA,W
083E:  MOVWF  xCC
0840:  MOVLW  00
0842:  SUBWFB xCB,W
0844:  MOVWF  xCD
0846:  CLRF   xE2
0848:  MOVLW  C8
084A:  MOVWF  xE1
084C:  CLRF   xE4
084E:  MOVLW  C9
0850:  MOVWF  xE3
0852:  MOVFF  CD,E6
0856:  MOVFF  CC,E5
085A:  RCALL  04BA
....................   } 
085C:  MOVF   xCA,W
085E:  BTFSC  FD8.2
0860:  DECF   xCB,F
0862:  DECF   xCA,F
0864:  BRA    0824
....................   output_low (PIN_B0); 
0866:  BCF    F93.0
0868:  BCF    F8A.0
....................  
....................   return keystream; 
086A:  MOVFF  C8,01
.................... } 
086E:  GOTO   08E8 (RETURN)
....................  
....................  
....................  
.................... /************** 
....................  * Cipherment * 
....................  **************/ 
....................  
....................  
....................  
.................... /*** 
....................  * reverse 
....................  * 
....................  * reverse input 
....................  * 
....................  */ 
.................... void reverse(u8* str, u64 length) { 
....................  
....................   u64 l = 0, r = length - 1; 
....................   u8 t1, t2; 
....................  
....................   for (; l < r; l++, r--) { 
....................     t1 = str[l]; 
....................     t2 = str[r]; 
....................  
....................     str[l] = t2; 
....................     str[r] = t1; 
....................   } 
....................  
....................   return; 
.................... } 
....................  
....................  
.................... /*** 
....................  * ip_cipher 
....................  * 
....................  * generate and apply keystream on input in place 
....................  * 
....................  */ 
.................... void ip_cipher(u8* key, u8* iv, u8* input, u64 length) { 
0872:  MOVFF  AE,B0
0876:  MOVFF  AD,AF
....................  
....................   u64 mark = length; 
....................   u64 iter; 
....................   u8 input_backup [16]; 
....................   memcpy(input_backup,input,16); 
087A:  CLRF   FEA
087C:  MOVLW  B3
087E:  MOVWF  FE9
0880:  MOVFF  AC,FE2
0884:  MOVFF  AB,FE1
0888:  MOVLW  10
088A:  MOVWF  01
088C:  MOVFF  FE6,FEE
0890:  DECFSZ 01,F
0892:  BRA    088C
....................   //reverse(key, KEYLENGTH); 
....................   //reverse(iv, IVLENGTH); 
....................  
....................   u8* state; 
....................   state = setup(key, iv); 
0894:  MOVFF  A8,C7
0898:  MOVFF  A7,C6
089C:  MOVFF  AA,C9
08A0:  MOVFF  A9,C8
08A4:  RCALL  02D4
08A6:  MOVFF  02,C4
08AA:  MOVFF  01,C3
....................   for (iter = 0; iter < (4 * 288); iter++){;update(state);} 
08AE:  CLRF   xB2
08B0:  CLRF   xB1
08B2:  MOVF   xB2,W
08B4:  SUBLW  04
08B6:  BNC   08D2
08B8:  BNZ   08C0
08BA:  MOVF   xB1,W
08BC:  SUBLW  7F
08BE:  BNC   08D2
08C0:  MOVFF  C4,CD
08C4:  MOVFF  C3,CC
08C8:  RCALL  0634
08CA:  INCF   xB1,F
08CC:  BTFSC  FD8.2
08CE:  INCF   xB2,F
08D0:  BRA    08B2
....................   u8 keystream; 
....................     
....................   //printf("\n___________keystream__________\n"); 
....................   output_high (PIN_B0); 
08D2:  BCF    F93.0
08D4:  BSF    F8A.0
....................   for (; mark > 0; mark--) { 
08D6:  MOVF   xAF,F
08D8:  BNZ   08DE
08DA:  MOVF   xB0,F
08DC:  BZ    0914
....................     keystream = stream(state); 
08DE:  MOVFF  C4,C7
08E2:  MOVFF  C3,C6
08E6:  BRA    081A
08E8:  MOVFF  01,C5
....................     //printf("|%02x|XOR|%02x|",keystream, input_backup[(length - mark)]);    
....................     input_backup[(length - mark)] ^= keystream; 
08EC:  MOVF   xAF,W
08EE:  SUBWF  xAD,W
08F0:  MOVWF  xC6
08F2:  MOVF   xB0,W
08F4:  SUBWFB xAE,W
08F6:  MOVWF  xC7
08F8:  MOVLW  B3
08FA:  ADDWF  xC6,W
08FC:  MOVWF  FE9
08FE:  MOVLW  00
0900:  ADDWFC xC7,W
0902:  MOVWF  FEA
0904:  MOVF   FEF,W
0906:  XORWF  xC5,W
0908:  MOVWF  FEF
....................   } 
090A:  MOVF   xAF,W
090C:  BTFSC  FD8.2
090E:  DECF   xB0,F
0910:  DECF   xAF,F
0912:  BRA    08D6
....................   output_low (PIN_B0); 
0914:  BCF    F93.0
0916:  BCF    F8A.0
....................   memcpy(input,input_backup,16); 
0918:  MOVFF  AC,FEA
091C:  MOVFF  AB,FE9
0920:  CLRF   FE2
0922:  MOVLW  B3
0924:  MOVWF  FE1
0926:  MOVLW  10
0928:  MOVWF  01
092A:  MOVFF  FE6,FEE
092E:  DECFSZ 01,F
0930:  BRA    092A
....................   return; 
.................... } 
0932:  GOTO   0970 (RETURN)
....................  
.................... u8 outputtt[16]; 
....................  
.................... /*** 
....................  * cipher 
....................  * 
....................  * generate and apply keystream 
....................  * 
....................  */ 
.................... u8* cipher(u8* key, u8* iv, u8* input, u64 length) { 
....................  
....................   //u8* outputtt; 
....................  
....................   memmove(outputtt, input, length); 
0936:  CLRF   xD9
0938:  MOVLW  2E
093A:  MOVWF  xD8
093C:  MOVFF  A4,DB
0940:  MOVFF  A3,DA
0944:  MOVFF  A6,DD
0948:  MOVFF  A5,DC
094C:  CALL   0004
....................   ip_cipher(key, iv, outputtt, length); 
0950:  MOVFF  A0,A8
0954:  MOVFF  9F,A7
0958:  MOVFF  A2,AA
095C:  MOVFF  A1,A9
0960:  CLRF   xAC
0962:  MOVLW  2E
0964:  MOVWF  xAB
0966:  MOVFF  A6,AE
096A:  MOVFF  A5,AD
096E:  BRA    0872
....................  
....................   return outputtt; 
0970:  MOVLW  2E
0972:  MOVWF  01
0974:  MOVLW  00
0976:  MOVWF  02
.................... } 
0978:  GOTO   099E (RETURN)
....................  
....................  
....................  
.................... /******** 
....................  * APIs * 
....................  ********/ 
....................  
....................  
....................  
.................... /*** 
....................  * ip_encrypt 
....................  * 
....................  * encrypt in place (syntactic sugar for in place cipher function) 
....................  * 
....................  */ 
.................... void ip_encrypt(u8* key, u8* iv, u8* input, u64 length) { 
....................   ip_cipher(key, iv, input, length); 
....................  
....................   return; 
.................... } 
....................  
....................  
.................... /*** 
....................  * ip_decrypt 
....................  * 
....................  * decrypt in place (syntactic sugar for in place cipher function) 
....................  * 
....................  */ 
.................... void ip_decrypt(u8* key, u8* iv, u8* input, u64 length) { 
....................   ip_cipher(key, iv, input, length); 
....................  
....................   return; 
.................... } 
....................  
....................  
.................... /*** 
....................  * encrypt 
....................  * 
....................  * encrypt (syntactic sugar for cipher function) 
....................  * 
....................  */ 
.................... u8* encrypt(u8* key, u8* iv, u8* input, u64 length) { 
....................   return cipher(key, iv, input, length); 
097C:  MOVFF  98,A0
0980:  MOVFF  97,9F
0984:  MOVFF  9A,A2
0988:  MOVFF  99,A1
098C:  MOVFF  9C,A4
0990:  MOVFF  9B,A3
0994:  MOVFF  9E,A6
0998:  MOVFF  9D,A5
099C:  BRA    0936
099E:  MOVF   02,W
.................... } 
09A0:  GOTO   0B5C (RETURN)
....................  
....................  
.................... /*** 
....................  * decrypt 
....................  * 
....................  * decrypt (syntactic sugar for cipher function) 
....................  * 
....................  */ 
.................... u8* decrypt(u8* key, u8* iv, u8* input, u64 length) { 
....................   return cipher(key, iv, input, length); 
.................... } 
....................  
.................... int convertdigit(char digit){ 
*
0346:  MOVLW  FF
0348:  MOVWF  x9B
....................     
....................    unsigned char value=-1; 
....................    switch (digit){ 
034A:  MOVLW  30
034C:  SUBWF  x9A,W
034E:  ADDLW  E9
0350:  BC    03B6
0352:  ADDLW  17
0354:  GOTO   03BC
....................     
....................    case '0': 
....................       value=0; 
0358:  CLRF   x9B
....................       break; 
035A:  BRA    03B6
....................    case '1': 
....................       value=1; 
035C:  MOVLW  01
035E:  MOVWF  x9B
....................       break; 
0360:  BRA    03B6
....................    case '2': 
....................       value=2; 
0362:  MOVLW  02
0364:  MOVWF  x9B
....................       break; 
0366:  BRA    03B6
....................    case '3': 
....................       value=3; 
0368:  MOVLW  03
036A:  MOVWF  x9B
....................       break; 
036C:  BRA    03B6
....................    case '4': 
....................       value=4; 
036E:  MOVLW  04
0370:  MOVWF  x9B
....................       break; 
0372:  BRA    03B6
....................    case '5': 
....................       value=5; 
0374:  MOVLW  05
0376:  MOVWF  x9B
....................       break; 
0378:  BRA    03B6
....................    case '6': 
....................       value=6; 
037A:  MOVLW  06
037C:  MOVWF  x9B
....................       break; 
037E:  BRA    03B6
....................    case '7': 
....................       value=7; 
0380:  MOVLW  07
0382:  MOVWF  x9B
....................       break;       
0384:  BRA    03B6
....................    case '8': 
....................       value=8; 
0386:  MOVLW  08
0388:  MOVWF  x9B
....................       break; 
038A:  BRA    03B6
....................    case '9': 
....................       value=9; 
038C:  MOVLW  09
038E:  MOVWF  x9B
....................       break; 
0390:  BRA    03B6
....................    case 'A': 
....................       value=10; 
0392:  MOVLW  0A
0394:  MOVWF  x9B
....................       break; 
0396:  BRA    03B6
....................    case 'B': 
....................       value=11; 
0398:  MOVLW  0B
039A:  MOVWF  x9B
....................       break;    
039C:  BRA    03B6
....................    case 'C': 
....................       value=12; 
039E:  MOVLW  0C
03A0:  MOVWF  x9B
....................       break; 
03A2:  BRA    03B6
....................    case 'D': 
....................       value=13; 
03A4:  MOVLW  0D
03A6:  MOVWF  x9B
....................       break; 
03A8:  BRA    03B6
....................    case 'E': 
....................       value=14; 
03AA:  MOVLW  0E
03AC:  MOVWF  x9B
....................       break; 
03AE:  BRA    03B6
....................    case 'F': 
....................       value=15; 
03B0:  MOVLW  0F
03B2:  MOVWF  x9B
....................       break;    
03B4:  BRA    03B6
....................    } 
....................  
....................    return value; 
03B6:  MOVFF  9B,01
.................... } 
03BA:  RETLW  00
.................... //Main program 
....................  
.................... void main() 
.................... { 
*
09CE:  CLRF   FF8
09D0:  BCF    FD0.7
09D2:  CLRF   FEA
09D4:  CLRF   FE9
09D6:  BSF    FB8.3
09D8:  MOVLW  E1
09DA:  MOVWF  FAF
09DC:  MOVLW  04
09DE:  MOVWF  FB0
09E0:  MOVLW  A6
09E2:  MOVWF  FAC
09E4:  MOVLW  90
09E6:  MOVWF  FAB
09E8:  MOVF   FC1,W
09EA:  ANDLW  C0
09EC:  IORLW  0F
09EE:  MOVWF  FC1
09F0:  MOVLW  07
09F2:  MOVWF  FB4
09F4:  CLRF   04
09F6:  CLRF   05
*
0A22:  CLRF   x96
....................  
....................    //arrays and variables  
....................    unsigned char in[16];   //space the plain text 
....................    u8 out[16];  //space for the cipher text 
....................    u8 key[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80}; 
*
09F8:  CLRF   5E
09FA:  CLRF   5F
09FC:  CLRF   x60
09FE:  CLRF   x61
0A00:  CLRF   x62
0A02:  CLRF   x63
0A04:  CLRF   x64
0A06:  CLRF   x65
0A08:  CLRF   x66
0A0A:  MOVLW  80
0A0C:  MOVWF  x67
....................    u8 iv[10]  = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; 
0A0E:  CLRF   x68
0A10:  CLRF   x69
0A12:  CLRF   x6A
0A14:  CLRF   x6B
0A16:  CLRF   x6C
0A18:  CLRF   x6D
0A1A:  CLRF   x6E
0A1C:  CLRF   x6F
0A1E:  CLRF   x70
0A20:  CLRF   x71
....................     
....................    char buffer[33];  //space to read the ASCII characters coming through the serial in 
....................    char hex[2]; //space for keeping hexadecimal ASCII representation of an 8 bit number 
....................    int i; 
....................    char temp=0; 
....................   
....................    //set the key    
....................    setup(key,iv);  
*
0A24:  CLRF   xC7
0A26:  MOVLW  5E
0A28:  MOVWF  xC6
0A2A:  CLRF   xC9
0A2C:  MOVLW  68
0A2E:  MOVWF  xC8
0A30:  RCALL  02D4
....................       
....................    //infinitely take plain text, encrypt and send cipher text back     
....................    while(1){ 
....................   
....................          //get the input character string to buffer. Since a plain text block is 128 bits it is 32 characters 
....................          for (i=0;i<32;i++){ 
0A32:  CLRF   x95
0A34:  MOVF   x95,W
0A36:  SUBLW  1F
0A38:  BNC   0A76
....................             buffer[i]=getc(); 
0A3A:  CLRF   03
0A3C:  MOVF   x95,W
0A3E:  ADDLW  72
0A40:  MOVWF  FE9
0A42:  MOVLW  00
0A44:  ADDWFC 03,W
0A46:  MOVWF  FEA
0A48:  BTFSS  F9E.5
0A4A:  BRA    0A48
0A4C:  MOVFF  FAE,FEF
....................           
....................          //some error correction mechanism. If the host sends a 'y' some issue has occurred, clean all the things in the buffer 
....................             if(buffer[i]=='y'){ 
0A50:  CLRF   03
0A52:  MOVF   x95,W
0A54:  ADDLW  72
0A56:  MOVWF  FE9
0A58:  MOVLW  00
0A5A:  ADDWFC 03,W
0A5C:  MOVWF  FEA
0A5E:  MOVF   FEF,W
0A60:  SUBLW  79
0A62:  BNZ   0A72
....................                while(kbhit()){ 
0A64:  BTFSS  F9E.5
0A66:  BRA    0A72
....................                     temp=getc(); 
0A68:  BTFSS  F9E.5
0A6A:  BRA    0A68
0A6C:  MOVFF  FAE,96
....................                } 
0A70:  BRA    0A64
....................             } 
....................           
....................          } 
0A72:  INCF   x95,F
0A74:  BRA    0A34
....................          buffer[i]=0; //terminating character 
0A76:  CLRF   03
0A78:  MOVF   x95,W
0A7A:  ADDLW  72
0A7C:  MOVWF  FE9
0A7E:  MOVLW  00
0A80:  ADDWFC 03,W
0A82:  MOVWF  FEA
0A84:  CLRF   FEF
....................           
....................          //convert the input string to a byte array 
....................          for(i=0;i<16;i++){ 
0A86:  CLRF   x95
0A88:  MOVF   x95,W
0A8A:  SUBLW  0F
0A8C:  BNC   0AF2
....................             hex[0]=buffer[i*2]; 
0A8E:  BCF    FD8.0
0A90:  RLCF   x95,W
0A92:  CLRF   03
0A94:  ADDLW  72
0A96:  MOVWF  FE9
0A98:  MOVLW  00
0A9A:  ADDWFC 03,W
0A9C:  MOVWF  FEA
0A9E:  MOVFF  FEF,93
....................             hex[1]=buffer[i*2+1]; 
0AA2:  BCF    FD8.0
0AA4:  RLCF   x95,W
0AA6:  ADDLW  01
0AA8:  CLRF   03
0AAA:  ADDLW  72
0AAC:  MOVWF  FE9
0AAE:  MOVLW  00
0AB0:  ADDWFC 03,W
0AB2:  MOVWF  FEA
0AB4:  MOVFF  FEF,94
....................             in[i]=convertdigit(hex[1])+16*convertdigit(hex[0]); 
0AB8:  CLRF   03
0ABA:  MOVF   x95,W
0ABC:  ADDLW  3E
0ABE:  MOVWF  01
0AC0:  MOVLW  00
0AC2:  ADDWFC 03,F
0AC4:  MOVFF  01,97
0AC8:  MOVFF  03,98
0ACC:  MOVFF  94,9A
0AD0:  RCALL  0346
0AD2:  MOVFF  01,99
0AD6:  MOVFF  93,9A
0ADA:  RCALL  0346
0ADC:  MOVF   01,W
0ADE:  MULLW  10
0AE0:  MOVF   FF3,W
0AE2:  ADDWF  x99,W
0AE4:  MOVFF  98,FEA
0AE8:  MOVFF  97,FE9
0AEC:  MOVWF  FEF
....................          } 
0AEE:  INCF   x95,F
0AF0:  BRA    0A88
....................  
....................          //prints the plain text via the serial port. The computer can check if communication happen properly 
....................          for (i=0;i<16;i++){ 
0AF2:  CLRF   x95
0AF4:  MOVF   x95,W
0AF6:  SUBLW  0F
0AF8:  BNC   0B1A
....................                printf("%2X", in[i] ); 
0AFA:  CLRF   03
0AFC:  MOVF   x95,W
0AFE:  ADDLW  3E
0B00:  MOVWF  FE9
0B02:  MOVLW  00
0B04:  ADDWFC 03,W
0B06:  MOVWF  FEA
0B08:  MOVFF  FEF,97
0B0C:  MOVFF  97,98
0B10:  MOVLW  37
0B12:  MOVWF  x99
0B14:  RCALL  0404
....................          } 
0B16:  INCF   x95,F
0B18:  BRA    0AF4
....................           
....................          //We need to repeatedly do the encryption on the plain text sample until the host computer aquires the power trace via the oscilloscope 
....................          //hence repeatedly do the encryption until host sends a signal to stop so 
....................          while(1){ 
....................           
....................          //if the host computer has sent a signal, get it and behave appropriately 
....................             if(kbhit()){ 
0B1A:  BTFSS  F9E.5
0B1C:  BRA    0B42
....................  
....................                temp=getc(); 
0B1E:  BTFSS  F9E.5
0B20:  BRA    0B1E
0B22:  MOVFF  FAE,96
....................                 
....................             //if the host sends 'z' thats the stopping signal and hence stop encryption and get ready to goto next round 
....................                if(temp=='z'){ 
0B26:  MOVF   x96,W
0B28:  SUBLW  7A
0B2A:  BNZ   0B30
....................                   break; 
0B2C:  BRA    0B80
....................                } 
....................              
....................                //if something other than 'z' is received clean everything in the buffers and get ready for the next round 
....................                else{ 
0B2E:  BRA    0B40
....................                   while(kbhit()){ 
0B30:  BTFSS  F9E.5
0B32:  BRA    0B3E
....................                      temp=getc(); 
0B34:  BTFSS  F9E.5
0B36:  BRA    0B34
0B38:  MOVFF  FAE,96
....................                   } 
0B3C:  BRA    0B30
....................                   break; 
0B3E:  BRA    0B80
....................                } 
....................             } 
....................           
....................                //if the host computer has sent no signal, repeatedly do the encryption 
....................             else{             
0B40:  BRA    0B7E
....................                //encryption 
....................                memcpy(out, encrypt(key, iv, in, 16), 16); 
0B42:  CLRF   x98
0B44:  MOVLW  5E
0B46:  MOVWF  x97
0B48:  CLRF   x9A
0B4A:  MOVLW  68
0B4C:  MOVWF  x99
0B4E:  CLRF   x9C
0B50:  MOVLW  3E
0B52:  MOVWF  x9B
0B54:  CLRF   x9E
0B56:  MOVLW  10
0B58:  MOVWF  x9D
0B5A:  BRA    097C
0B5C:  MOVFF  02,98
0B60:  MOVFF  01,97
0B64:  CLRF   FEA
0B66:  MOVLW  4E
0B68:  MOVWF  FE9
0B6A:  MOVFF  02,FE2
0B6E:  MOVFF  01,FE1
0B72:  MOVLW  10
0B74:  MOVWF  01
0B76:  MOVFF  FE6,FEE
0B7A:  DECFSZ 01,F
0B7C:  BRA    0B76
....................             } 
....................          } 
0B7E:  BRA    0B1A
....................          /* 
....................          memcpy(out, encrypt(key, iv, in, 16), 16); 
....................          delay_ms(5); 
....................          */ 
....................          //prints the cipher text to verify by the host whether cryptosystem is ing properly 
....................          for (i=0;i<16;i++){ 
0B80:  CLRF   x95
0B82:  MOVF   x95,W
0B84:  SUBLW  0F
0B86:  BNC   0BA8
....................                printf("%2X", out[i] ); 
0B88:  CLRF   03
0B8A:  MOVF   x95,W
0B8C:  ADDLW  4E
0B8E:  MOVWF  FE9
0B90:  MOVLW  00
0B92:  ADDWFC 03,W
0B94:  MOVWF  FEA
0B96:  MOVFF  FEF,97
0B9A:  MOVFF  97,98
0B9E:  MOVLW  37
0BA0:  MOVWF  x99
0BA2:  RCALL  0404
....................          } 
0BA4:  INCF   x95,F
0BA6:  BRA    0B82
....................           
....................          //just keep a delay 
....................          delay_ms(5); 
0BA8:  MOVLW  05
0BAA:  MOVWF  x97
0BAC:  BRA    09A4
....................   
....................    } 
0BAE:  BRA    0A32
.................... } 
....................  
....................  
....................  
0BB0:  SLEEP 

Configuration Fuses:
   Word  1: CE21   PLL2 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV20 NOVREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
